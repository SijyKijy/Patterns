# Прототип (Prototype)
**Порождающий паттерн** проектирования, который позволяет **копировать объекты любой сложности, не вдаваясь в подробности их реализации**.

В C# есть уже готовая конструкция для этого паттерна - [ICloneable](https://docs.microsoft.com/ru-ru/dotnet/api/system.icloneable)

## Пример
Деление клеток

## Когда применять
* Когда ваш код **не должен зависеть** от классов копируемых объектов
* Когда вы имеете уйму подклассов, которые **отличаются начальными значениями полей**.
Кто-то мог создать все эти классы, чтобы иметь возможность легко порождать объекты с определённой конфигурацией

## Плюсы и минусы
+|-
----|----
Позволяет клонировать объекты, не привязываясь к их конкретным классам | **Сложно клонировать составные объекты**, имеющие ссылки на другие объекты
Меньше повторяющегося кода инициализации объектов |
Ускоряет создание объектов |
Альтернатива созданию подклассов для конструирования сложных объектов |

## Шаги реализации
1. Создайте интерфейс прототипов с единственным методом clone. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов.
2. Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.

Если ваш язык программирования не поддерживает перегрузку методов, то вам не удастся создать несколько версий конструктора. В этом случае копирование значений можно проводить и в другом методе, специально созданном для этих целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.

3. Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы использовать собственный класс с оператором new. В обратном случае результатом клонирования станет объект родительского класса.
4. Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно, даже одного класса, но по-разному настроенных.

Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. Такой фабричный метод должен на основании входящих аргументов искать в хранилище прототипов подходящий экземпляр, а затем вызывать его метод клонирования и возвращать полученный объект.

Наконец, нужно избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.
## Источник
[Подробнее тут](https://refactoring.guru/ru/design-patterns/prototype)