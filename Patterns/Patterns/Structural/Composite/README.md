# Компоновщик / Дерево (Composite)
**Структурный паттерн** проектирования, который позволяет **сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект**

## Цель:
Работа со сложным вложенным объектом как с единым простым

## Пример
Есть два объекта: `Продукт` и `Коробка`.
`Коробка` может содержать несколько `Продуктов` и других `Коробок` поменьше.
Те, в свою очередь `Коробка`, тоже содержат либо `Продукты`, либо `Коробки` и так далее

## Когда применять
* Когда вам нужно представить древовидную структуру объектов
* Когда клиенты должны единообразно трактовать простые и составные объекты

## Плюсы и минусы
+|-
----|----
Облегчает добавление новых видов компонентов | Создаёт слишком общий дизайн классов
Упрощает архитектуру клиента при работе со сложным деревом компонентов |

## Шаги реализации
1. Убедитесь, что вашу бизнес-логику можно представить как древовидную структуру. Попытайтесь разбить её на простые компоненты и контейнеры. Помните, что контейнеры могут содержать как простые компоненты, так и другие вложенные контейнеры.
2. Создайте общий интерфейс компонентов, который объединит операции контейнеров и простых компонентов дерева. Интерфейс будет удачным, если вы сможете использовать его, чтобы взаимозаменять простые и составные компоненты без потери смысла.
3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений. Имейте в виду, что программа может содержать несколько таких классов.
4. Создайте класс компонентов-контейнеров и добавьте в него массив для хранения ссылок на вложенные компоненты. Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь, что он объявлен с типом интерфейса компонентов.

> Реализуйте в контейнере методы интерфейса компонентов, помня о том, что контейнеры должны делегировать основную работу своим дочерним компонентам.

5. Добавьте операции добавления и удаления дочерних компонентов в класс контейнеров.

> Имейте в виду, что методы добавления/удаления дочерних компонентов можно поместить и в интерфейс компонентов. Да, это нарушит принцип разделения интерфейса, так как реализации методов будут пустыми в компонентах-листьях. Но зато все компоненты дерева станут действительно одинаковыми для клиента.

## Источник
[Подробнее тут](https://refactoring.guru/ru/design-patterns/composite)

[Википедия](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%BE%D0%B2%D1%89%D0%B8%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))