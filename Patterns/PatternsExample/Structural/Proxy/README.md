# Заместитель (Proxy)
**Структурный паттерн** проектирования, **предоставляющий объект (прослойку)**, который **контролирует доступ к другому объекту**, **перехватывая все вызовы** до или после.

Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

## Цель
Контролировать доступ к объекту через определённую прослойку (proxy)

## Пример
Прослойка между клиентом и сервером

## Когда применять
* В случаях работы с сетевым соединением
* С огромным объектом в памяти (или на диске) или с любым другим ресурсом, который сложно или тяжело копировать.

> Хорошо известный пример применения - объект, подсчитывающий число ссылок. *(Алгоритм подсчёта ссылок из GC)*

## Плюсы и минусы
+|-
----|----
Позволяет контролировать сервисный объект (реальный субъект) незаметно для клиента | **Увеличивает время отклика от сервиса**
Может работать, даже если сервисный объект ещё не создан (**Не во всех [видах](#Виды)**) |  Усложняет код программы из-за введения дополнительных классов
Может контролировать жизненный цикл служебного объекта |

## Виды
У паттерна заместитель (прокси) есть свои виды (реализации):

* **Протоколирующий (логирующий) заместитель** - сохраняет в некий "лог" все вызовы сервисного объекта, вместе с его параметрами
* **Удаленный заместитель** - обеспечивает правильную связь с удаленным сервисным объектом, который находится в другом адресном пространстве или на удаленной машине.
> 💡 **Дополнительно**: Берет на себя логику по кодирование/декодирование запроса/ответа удаленного сервиса
* **Виртуальный заместитель** (отложенная инициализация) -  обеспечивает создание экземпляра сервисного объекта при необходимости.
> 💡 **Дополнительно**: Может кэшировать часть информации созданного сервисного объекта, чтобы отложить его создание
* **Копирование при записи (Частный случай виртуального заместителя)** - обеспечивает полное копирование сервисного объекта после выполнения клиентом определенных действий (задаёт разраб) над заместителем
* **Защищающий заместитель (проверка доступа)** - проверяет при каждом вызове имеет ли вызывающий объект (со стороны клиента) необходимые права для выполнения запроса.
> Если да - заместитель обращается к сервисному объекту с заданными параметрами
* **Кэширующий заместитель** - обеспечивает временное хранение результатов запросов до отдачи их множественным клиентам
* **Экранирующий заместитель (защищающий)** - защищает сервисный объект от опасных действий со стороны клиента (клиентов) (Или наоборот)
* **Синхронизирующий заместитель** - производит синхронизацию при запросе к сервисному объекту в многопоточной или асинхронной модели
* **"Умная" ссылка** - производит доп. действия при создании ссылки на сервисный объект
> 💡 **Пример**: Подсчет всех ссылок (аналог алгоритма подсчёта ссылок из GC)

## Шаги реализации
1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект создаётся самим заместителем. В редких случаях заместитель получает готовый сервисный объект от клиента через конструктор.
3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос сервисному объекту.
4. Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный сервисный объект. Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.
5. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя.

## Источник
[Подробнее тут](https://refactoring.guru/ru/design-patterns/proxy)

[Википедия](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))